#include <YutsuOS/core/byte.h>
#include <YutsuOS/core/interrupts.h>
#include <YutsuOS/core/panic.h>

/**
 * @file interrupts.c
 * @brief Core interrupt handling and dispatching for YutsuOS.
 *
 * This module provides registration of custom interrupt handlers
 * and defines the default dispatch routines for CPU exceptions (ISRs)
 * and hardware interrupts (IRQs).
 */

#define ISR_VECTOR_COUNT 32  /**< CPU exception vectors (0–31) */
#define IRQ_VECTOR_OFFSET 32 /**< IRQ0 starts at vector 32 after PIC remap */
#define IRQ_SLAVE_OFFSET 40  /**< IRQ8 starts at vector 40 (slave PIC) */

/**
 * static global
 */

/**
 * @brief Table of registered interrupt service routines.
 *
 * Each entry corresponds to an interrupt vector (0–255).
 * If no handler is registered, the entry remains NULL.
 */
static Isr g_interrupt_handlers[YUTSUOS_CORE_IDT_ENTRIES] = {0};

/**
 * public
 */

/**
 * @brief Register a custom interrupt handler for a specific vector.
 *
 * @param n       Interrupt vector number (0–255)
 * @param handler Pointer to the ISR handler function
 */
void register_interrupt_handler(u8 n, Isr handler)
{
    g_interrupt_handlers[n] = handler;
}

/**
 * @brief Central handler for CPU exceptions (ISRs 0–31).
 *
 * These are faults and traps generated by the CPU itself (e.g. divide by zero,
 * page fault, general protection fault, etc.). If unhandled, the kernel
 * halts with a panic.
 *
 * @param regs Pointer to the CPU register state at the time of the exception.
 */
void isr_handler(Registers *regs)
{
    if (regs->int_no < ISR_VECTOR_COUNT)
    {
        panic("Unhandled CPU exception (ISR #%u)", regs->int_no);
    }
}

/**
 * @brief Central handler for hardware interrupts (IRQs 0–15).
 *
 * Acknowledges the interrupt controllers (PIC1, PIC2) and then calls
 * the registered handler, if any.
 *
 * @param regs Pointer to the CPU register state at the time of the interrupt.
 */
void irq_handler(Registers *regs)
{
    /* send End-of-Interrupt (EOI) to the PICs */
    if (regs->int_no >= IRQ_SLAVE_OFFSET)
    {
        __yutsuos_core_io_outb(PIC2_COMMAND, PIC_EOI);
    }

    __yutsuos_core_io_outb(PIC1_COMMAND, PIC_EOI);

    /* Dispatch to the registered handler if available */
    const Isr handler = g_interrupt_handlers[regs->int_no];

    if (handler)
    {
        handler(regs);
    }
}
